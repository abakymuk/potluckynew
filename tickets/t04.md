T0.4 — RLS (multi-tenant) + автопрофиль + e2e-проверки доступа

Role: Codebase Guardian (Edge/Serverless).
Non-negotiables: в рантайме — только anon-клиент Supabase с RLS; service-role разрешён только в миграциях/сидерах/тестах.

Goal

Включить RLS и ввести строгие политики для organizations, profiles, memberships.
Добавить безопасные SQL-функции:
• auth_profile_id() — получить profiles.id по JWT (без прав на таблицу),
• триггер автосоздания profiles при появлении нового пользователя в auth.users.
Покрыть e2e-тестами: «свой/чужой» доступ.

Scope

In: SQL-политики, функции, триггер, скрипт применения, e2e-тесты через supabase-js.
Out: бизнес-таблицы (orders и т. п.), API-роуты с авторизацией (это в T0.5).

AC (Gherkin)
• Given пользователь Alice аутентифицирован и является участником организации Acme,
When делает select organizations,
Then видит только Acme.
• Given пользователь Bob аутентифицирован и не состоит в Acme,
When делает select organizations,
Then не видит Acme.
• Given анонимный клиент,
When делает select profiles,
Then не получает ни одной строки (или ошибку по RLS).
• Given Alice,
When делает select profiles,
Then видит только свою строку профиля.

DoD
• Включён RLS на organizations, profiles, memberships
• Добавлены функции auth_profile_id() (SECURITY DEFINER) и триггер автопрофиля
• Политики select для трёх таблиц соответствуют AC
• Скрипт pnpm db:rls применяет rls.sql
• e2e-тесты создают двух пользователей, проверяют изоляцию

⸻

Steps

0. Зависимости (уже есть, дополним для тестов)

pnpm -w add -D dotenv

1. SQL: функции, триггер, политики

Создай файл infra/db/rls.sql:

-- ========= Helpers =========
create or replace function public.auth_profile_id()
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
pid uuid;
begin
-- auth.uid() читает sub из JWT; для anon = null
select p.id into pid
from public.profiles p
where p.auth_user_id = auth.uid()
limit 1;
return pid;
end;

$$
;

grant execute on function public.auth_profile_id() to anon, authenticated;

-- Автосоздание профиля при появлении пользователя в auth.users
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as
$$

begin
insert into public.profiles (auth_user_id, full_name)
values (new.id, coalesce(new.raw_user_meta_data->>'full_name', ''))
on conflict (auth_user_id) do nothing;
return new;
end;

$$
;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- ========= Enable RLS =========
alter table public.organizations enable row level security;
alter table public.profiles      enable row level security;
alter table public.memberships   enable row level security;

-- ========= Policies =========

-- profiles: пользователь видит только свой профиль
drop policy if exists profiles_self_select on public.profiles;
create policy profiles_self_select
  on public.profiles
  for select
  using (id = public.auth_profile_id());

-- organizations: видим только те, где есть membership текущего профиля
drop policy if exists orgs_member_select on public.organizations;
create policy orgs_member_select
  on public.organizations
  for select
  using (
    exists (
      select 1
      from public.memberships m
      where m.org_id = organizations.id
        and m.profile_id = public.auth_profile_id()
    )
  );

-- memberships: видим только свои строки membership
drop policy if exists memberships_self_select on public.memberships;
create policy memberships_self_select
  on public.memberships
  for select
  using (profile_id = public.auth_profile_id());

-- (Опционально) Запретить insert/update/delete по умолчанию.
-- Будущие операции добавим через безопасные RPC (SECURITY DEFINER).
revoke insert, update, delete on public.organizations from anon, authenticated;
revoke insert, update, delete on public.profiles      from anon, authenticated;
revoke insert, update, delete on public.memberships   from anon, authenticated;

Почему SECURITY DEFINER у функций: чтобы запросы в политиках могли безопасно читать profiles, не полагаясь на права текущего пользователя.

2) Скрипт применения RLS

infra/db/apply-rls.ts:

import 'dotenv/config'
import { readFileSync } from 'node:fs'
import { Client } from 'pg'

const url = process.env.SUPABASE_DB_URL
if (!url) throw new Error('SUPABASE_DB_URL is required')

async function main() {
  const sql = readFileSync('./infra/db/rls.sql', 'utf8')
  const client = new Client({ connectionString: url })
  await client.connect()
  await client.query(sql)
  await client.end()
  console.log('RLS applied')
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})

Добавь в root package.json:

{
  "scripts": {
    "db:rls": "tsx ./infra/db/apply-rls.ts"
  }
}

3) Seed: создаём двух пользователей и участника org

Обнови infra/db/seed.ts (добавим админ-создание пользователей):

import 'dotenv/config'
import { Client } from 'pg'
import { createClient } from '@supabase/supabase-js'

const url = process.env.SUPABASE_DB_URL
if (!url) throw new Error('SUPABASE_DB_URL is required')

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!
const SERVICE_ROLE = process.env.SUPABASE_SERVICE_ROLE!
if (!SUPABASE_URL || !SERVICE_ROLE) {
  throw new Error('NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE are required to seed users')
}

const admin = createClient(SUPABASE_URL, SERVICE_ROLE, { auth: { persistSession: false } })
const client = new Client({ connectionString: url })

async function ensureUser(email: string, password: string, fullName: string) {
  const { data: existing } = await admin.auth.admin.listUsers()
  const found = existing.users?.find(u => u.email === email)
  if (!found) {
    const { data, error } = await admin.auth.admin.createUser({
      email, password, email_confirm: true,
      user_metadata: { full_name: fullName }
    })
    if (error) throw error
    return data.user!.id
  }
  return found.id
}

async function main() {
  await client.connect()

  // пользователи
  const aliceId = await ensureUser('alice@example.com', 'Passw0rd!', 'Alice')
  const bobId   = await ensureUser('bob@example.com',   'Passw0rd!', 'Bob')

  // организация
  const orgRes = await client.query(
    `insert into organizations (name)
     values ('Acme') on conflict do nothing returning id`
  )
  const orgId = orgRes.rows[0]?.id ?? (await client.query(
    `select id from organizations where name='Acme' limit 1`
  )).rows[0].id

  // дождёмся автопрофилей из триггера и получим их id
  const qProfile = async (auth_user_id: string) =>
    (await client.query(`select id from profiles where auth_user_id=$1 limit 1`, [auth_user_id])).rows[0]?.id

  // простая ретрия
  const waitProfile = async (uid: string) => {
    for (let i=0;i<10;i++){
      const pid = await qProfile(uid)
      if (pid) return pid
      await new Promise(r => setTimeout(r, 300))
    }
    throw new Error('profile not created by trigger')
  }
  const aliceProfileId = await waitProfile(aliceId)
  const bobProfileId   = await waitProfile(bobId)

  // membership: Alice -> Acme (owner)
  await client.query(
    `insert into memberships (org_id, profile_id, role)
     values ($1, $2, 'owner')
     on conflict (org_id, profile_id) do nothing`,
    [orgId, aliceProfileId]
  )

  console.log('Seed complete:', { orgId, aliceProfileId, bobProfileId })
  await client.end()
}
main().catch(async (e) => {
  console.error(e)
  await client.end().catch(() => {})
  process.exit(1)
})

Требуются env: SUPABASE_DB_URL, NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE.

4) e2e-тесты RLS (Node, без Next.js)

Создай infra/db/tests/rls.e2e.test.ts:

import 'dotenv/config'
import { describe, it, expect, beforeAll } from 'vitest'
import { createClient, SupabaseClient } from '@supabase/supabase-js'

const URL = process.env.NEXT_PUBLIC_SUPABASE_URL as string
const ANON = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string

let supabaseAnon: SupabaseClient
let alice: SupabaseClient
let bob: SupabaseClient

async function signIn(email: string, password: string) {
  const c = createClient(URL, ANON, { auth: { persistSession: false } })
  const { data, error } = await c.auth.signInWithPassword({ email, password })
  if (error) throw error
  return createClient(URL, ANON, {
    global: { headers: { Authorization: `Bearer ${data.session!.access_token}` } },
    auth: { persistSession: false }
  })
}

describe('RLS policies', () => {
  beforeAll(async () => {
    supabaseAnon = createClient(URL, ANON, { auth: { persistSession: false } })
    alice = await signIn('alice@example.com', 'Passw0rd!')
    bob   = await signIn('bob@example.com',   'Passw0rd!')
  })

  it('anon cannot read profiles', async () => {
    const { data, error } = await supabaseAnon.from('profiles').select('*')
    // В Supabase для anon обычно ошибка по RLS: data=null, error=null + count=0 или error 401.
    expect(error || (Array.isArray(data) && data.length === 0)).toBeTruthy()
  })

  it('alice sees only her profile', async () => {
    const { data, error } = await alice.from('profiles').select('id, auth_user_id')
    expect(error).toBeNull()
    expect(Array.isArray(data)).toBe(true)
    expect(data!.length).toBe(1)
  })

  it('alice sees Acme org, bob does not', async () => {
    const a = await alice.from('organizations').select('id, name')
    expect(a.error).toBeNull()
    expect(a.data!.some(o => o.name === 'Acme')).toBe(true)

    const b = await bob.from('organizations').select('id, name')
    expect(b.error).toBeNull()
    expect(b.data!.some(o => o.name === 'Acme')).toBe(false)
  })

  it('memberships are visible only to the profile owner', async () => {
    const am = await alice.from('memberships').select('org_id, profile_id, role')
    const bm = await bob.from('memberships').select('org_id, profile_id, role')
    expect(am.error).toBeNull()
    expect(bm.error).toBeNull()
    expect((am.data ?? []).length).toBeGreaterThanOrEqual(1)
    expect((bm.data ?? []).length).toBe(0)
  })
})

Добавь в root package.json:

{
  "scripts": {
    "test:rls": "vitest run infra/db/tests/rls.e2e.test.ts"
  }
}

5) Порядок запуска (локально / CI)

# ENV
export NEXT_PUBLIC_SUPABASE_URL=...
export NEXT_PUBLIC_SUPABASE_ANON_KEY=...
export SUPABASE_DB_URL=...
export SUPABASE_SERVICE_ROLE=...

# миграции и сид
pnpm drizzle:generate
pnpm drizzle:push
pnpm db:rls
pnpm db:seed

# e2e-тесты RLS
pnpm test:rls


⸻

README — добавить раздел «RLS»

### RLS & Auth
- RLS включён на organizations/profiles/memberships.
- Функция `auth_profile_id()` (SECURITY DEFINER) — безопасно вычисляет профиль по JWT.
- Триггер `on_auth_user_created` создаёт профиль при регистрации.
- В рантайме используются только anon-ключи; все доступы контролируются RLS.
- Для сидов/тестов необходим `SUPABASE_SERVICE_ROLE`.

Рекомендованный коммит

feat(rls): enable RLS with secure policies, auto-profile trigger and e2e isolation tests
$$
