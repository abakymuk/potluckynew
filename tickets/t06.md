T0.6 — Наблюдаемость: Sentry (web+edge) + базовый OTEL-трейсинг

Role: Codebase Guardian (Edge/Serverless).
Non-negotiables: инициализация Sentry в клиенте/сервере/edge, загрузка sourcemaps в CI, единый способ включать/выключать. Никаких «тихих» ошибок — всегда логируем.

Goal

Подключить Sentry к Next.js (client + server + edge runtime), настроить загрузку sourcemaps из CI и включить базовые трейсы (через Sentry Tracing + Vercel OTEL). Добавить тестовый эндпоинт /api/ping с принудительной ошибкой для проверки сигналов.

Scope

In: @sentry/nextjs, конфиги sentry.\*.config.ts, обёртка withSentryConfig, загрузка sourcemaps, demo-маршрут /api/ping, минимальные OTEL-настройки.
Out: дашборды Grafana/Tempo/OTLP-коллекторы, детальная метрика БД — позже.

AC (Gherkin)
• Given GET /api/ping, When без параметров, Then 200 { ok:true }.
• Given GET /api/ping?fail=1, When вызываю, Then 500 { error:"ping_failed" } и событие появляется в Sentry с тегом runtime=edge.
• Given выполняю CI build с SENTRY_AUTH_TOKEN/SENTRY_ORG/SENTRY_PROJECT, Then sourcemaps загружены в релиз и ошибки символизируются.
• Given VERCEL_OTEL=1 в проде, Then в Sentry видны базовые трассы HTTP для API-роутов.

DoD
• Установлен @sentry/nextjs, добавлены sentry.client.config.ts, sentry.server.config.ts, sentry.edge.config.ts
• next.config.mjs обёрнут в withSentryConfig (source maps)
• Добавлен /api/ping с опцией инъекции ошибки и captureException
• В CI: job, который билдит и загружает sourcemaps (на preview/main)
• Обновлён packages/config для NEXT_PUBLIC_SENTRY_DSN (необязательно, но поддерживается)
• README: переменные окружения и проверка руками

⸻

Steps

0. Зависимости

pnpm --filter @potlucky/web add @sentry/nextjs
pnpm -w add -D @sentry/cli

1. (Минорное расширение) @potlucky/config — поддержка Sentry DSN

Добавим необязательные поля, чтобы не ломать сборку, и удобный геттер.

packages/config/src/schema.ts — в PublicEnvSchema:

NEXT_PUBLIC_SENTRY_DSN: z.string().url().optional(),

в ServerEnvSchema уже есть SENTRY_DSN?: string.

packages/config/src/public.ts — экспорт helper:

export const getSentryDsn = () =>
envPublic.NEXT_PUBLIC_SENTRY_DSN ?? process.env.SENTRY_DSN ?? ''

packages/config/src/index.ts

export { envPublic, flags, isEnabled, getSentryDsn } from './public'

Если не хочешь трогать публичную схему — можно оставить только SENTRY_DSN (работает и в клиенте, Sentry DSN публичный по природе). Вариант выше — гибче.

2. Конфиги Sentry (Next.js picks them up автоматически)

apps/web/sentry.client.config.ts

import \* as Sentry from '@sentry/nextjs'
import { getSentryDsn } from '@potlucky/config'

Sentry.init({
dsn: getSentryDsn() || process.env.SENTRY_DSN,
environment: process.env.VERCEL_ENV || process.env.NODE_ENV,
tracesSampleRate: 0.2, // базовые трассы UI
replaysOnErrorSampleRate: 1.0,
replaysSessionSampleRate: 0.05,
integrations: (integrations) => integrations,
})

apps/web/sentry.server.config.ts

import \* as Sentry from '@sentry/nextjs'
import { getSentryDsn } from '@potlucky/config'

Sentry.init({
dsn: getSentryDsn() || process.env.SENTRY_DSN,
environment: process.env.VERCEL_ENV || process.env.NODE_ENV,
tracesSampleRate: 0.3, // серверные Route Handlers (node)
profilesSampleRate: 0.0,
})

apps/web/sentry.edge.config.ts

import \* as Sentry from '@sentry/nextjs'
import { getSentryDsn } from '@potlucky/config'

Sentry.init({
dsn: getSentryDsn() || process.env.SENTRY_DSN,
environment: process.env.VERCEL_ENV || process.env.NODE_ENV,
tracesSampleRate: 0.3, // трассируем edge-функции
})

3. Обёртка next.config и sourcemaps

apps/web/next.config.mjs

import { withSentryConfig } from '@sentry/nextjs'

/\*_ @type {import('next').NextConfig} _/
const nextConfig = {
experimental: { staleTimes: { dynamic: 0 } },
// прочие твои настройки
}

export default withSentryConfig(nextConfig, {
org: process.env.SENTRY_ORG,
project: process.env.SENTRY_PROJECT,
// автоматическая загрузка sourcemaps во время next build
silent: true,
widenClientFileUpload: true,
dryRun: !process.env.SENTRY_AUTH_TOKEN, // локально не загружать
})

Альтернатива: отдельный шаг sentry-cli sourcemaps upload. Но withSentryConfig проще и надёжнее.

4. Демонстрационный эндпоинт /api/ping (Edge)

apps/web/app/api/ping/route.ts

export const runtime = 'edge'

import \* as Sentry from '@sentry/nextjs'

export async function GET(req: Request) {
const url = new URL(req.url)
const shouldFail = url.searchParams.get('fail') === '1'

if (shouldFail) {
try {
throw new Error('Ping failure (forced)')
} catch (e) {
const eventId = Sentry.captureException(e)
return new Response(JSON.stringify({ error: 'ping_failed', eventId }), {
status: 500,
headers: { 'content-type': 'application/json' },
})
}
}

return new Response(JSON.stringify({ ok: true }), {
headers: { 'content-type': 'application/json' },
})
}

5. Базовый OTEL
   • В Vercel включи переменную окружения VERCEL_OTEL=1 (или флажок Telemetry, если доступен).
   • Sentry перехватывает трассы через свою интеграцию с OTEL/Next — этого достаточно для стартового уровня.

Опционально добавим request-id тег для всех ответов:

apps/web/middleware.ts (в начале функции, после requestHeaders):

const rid = requestHeaders.get('x-request-id') ?? crypto.randomUUID()
requestHeaders.set('x-request-id', rid)

И в sentry.\*.config.ts можно добавить:

beforeSend(event) {
// @ts-ignore
const rid = event.request?.headers?.['x-request-id']
if (rid) event.tags = { ...(event.tags ?? {}), request_id: rid }
return event
}

6. CI: сборка + загрузка sourcemaps

Создай infra/ci/observability.yml:

name: observability
on:
push:
branches: [ main ]
pull_request:

jobs:
build-and-upload-sourcemaps:
runs-on: ubuntu-latest
env:
SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
NEXT_PUBLIC_SENTRY_DSN: ${{ secrets.SENTRY_DSN }} # если используешь public-переменную
steps: - uses: actions/checkout@v4 - uses: pnpm/action-setup@v4
with: { version: 9 } - run: pnpm i --frozen-lockfile - run: pnpm --filter @potlucky/web build # withSentryConfig сам загружает sourcemaps во время build, # если SENTRY_AUTH_TOKEN/ORG/PROJECT заданы.

Хочешь отдельный релиз-нейм — добавь SENTRY_RELEASE в env и передай его в withSentryConfig (полезно для монореп с несколькими apps).

7. Тесты

apps/web/tests/ping.test.ts

import { describe, it, expect } from 'vitest'
import { GET } from '../app/api/ping/route'

describe('/api/ping', () => {
it('returns ok', async () => {
const res = await GET(new Request('http://localhost/api/ping'))
expect(res.status).toBe(200)
const body = await res.json()
expect(body).toEqual({ ok: true })
})
it('captures error on fail=1', async () => {
const res = await GET(new Request('http://localhost/api/ping?fail=1'))
expect(res.status).toBe(500)
const body = await res.json()
expect(body.error).toBe('ping_failed')
// eventId может быть undefined в тесте, важно лишь что 500 и структура
})
})

8. ENV (локально/CI)

# Sentry

SENTRY_DSN= https://<key>@o<org>.ingest.sentry.io/<project>
SENTRY_AUTH_TOKEN= <token with project:releases, org:read, project:read>
SENTRY_ORG= <your-org-slug>
SENTRY_PROJECT= <your-project-slug>

# optionally (public)

NEXT_PUBLIC_SENTRY_DSN= https://<same dsn>

# Vercel OTEL (в прод-окружении/preview)

VERCEL_OTEL=1

9. README — «Как проверить»

## Sentry check

1. Установи переменные: SENTRY_DSN (и в CI — AUTH_TOKEN/ORG/PROJECT).
2. Локально: `pnpm --filter @potlucky/web dev`
3. Открой: /api/ping?fail=1 → 500 и вернёт { error, eventId }.
4. Проверь событие в Sentry (тег runtime=edge, request_id если включён).

⸻

Команды проверки

# локально

export SENTRY_DSN="https://<key>@o<org>.ingest.sentry.io/<project>"
pnpm --filter @potlucky/web build
pnpm --filter @potlucky/web dev
curl -s localhost:3000/api/ping
curl -s localhost:3000/api/ping?fail=1

Рекомендованный коммит

feat(observability): add Sentry (client/server/edge), sourcemap upload in CI, ping route for error testing
