T0.5 — Auth на Edge: middleware + user/org-контекст + защищённый API-роут

Role: Codebase Guardian (Edge/Serverless).
Non-negotiables: в рантайме используем только anon-ключ + RLS. Service-role — лишь для сидов/миграций. Никаких прямых process.env вне @potlucky/config.

Goal 1. Включить аутентификацию на Edge через Supabase SSR. 2. В middleware прокидывать x-user-id (и опционально x-org-id из cookie org_id) в каждый запрос. 3. Реализовать защищённый роут /api/me (Edge) — возвращает профиль и memberships текущего пользователя; без сессии → 401. 4. Дать удобный helper для получения Supabase-клиента из Request (авторизация через Authorization: Bearer <token> или SSR-cookies).

Scope

In: middleware.ts, helpers lib/auth.ts, lib/supabase.ts, роут /api/me, базовые тесты.
Out: UI-экраны логина/выбора организации, refresh-логика org_id, сложные стратегии контекста.

AC (Gherkin)
• Given запрос к /api/me без авторизации, When вызываю GET /api/me, Then получаю 401 { error: "unauthorized" }.
• Given токен Alice (из сидов T0.4), When GET /api/me с Authorization: Bearer <token>, Then 200 и JSON с её profile и хотя бы одним membership в Acme.
• Given токен Bob, When GET /api/me, Then 200, profile Bob и memberships пуст или без Acme.
• Given у запроса есть валидная сессия, Then middleware прокидывает заголовок x-user-id=<auth.user.id>; при наличии cookie org_id → добавляется x-org-id.

DoD
• apps/web/middleware.ts — прокидывает x-user-id/x-org-id в request headers
• apps/web/lib/supabase.ts — createSupabaseForRequest(req, resHeaders?) (Edge-совместимо)
• apps/web/lib/auth.ts — getUserOrThrow(req) (возвращает user или кидает 401)
• apps/web/app/api/me/route.ts — защищённый роут (Edge), отдаёт профиль+мембершипы
• Тесты: 401 без токена; 200 с Alice; 200 с Bob (без Acme)
• README: как получить токен локально для ручной проверки

⸻

Steps

0. Зависимости

pnpm -w add @supabase/ssr

1. Edge-middleware: прокинуть user/org контекст в заголовки

apps/web/middleware.ts

import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { envPublic } from '@potlucky/config'

export async function middleware(req: NextRequest) {
// Сформируем новые заголовки запроса, которые полетят дальше в роут-хендлеры
const requestHeaders = new Headers(req.headers)

// SSR-клиент Supabase (Edge-совместим)
const supabase = createServerClient(
envPublic.NEXT_PUBLIC_SUPABASE_URL,
envPublic.NEXT_PUBLIC_SUPABASE_ANON_KEY,
{
cookies: {
get(name: string) {
return req.cookies.get(name)?.value
},
set() { /_ noop: middleware не устанавливает cookie _/ },
remove() { /_ noop _/ },
},
}
)

try {
const { data: { user } } = await supabase.auth.getUser()
if (user?.id) {
requestHeaders.set('x-user-id', user.id)
const orgId = req.cookies.get('org_id')?.value
if (orgId) requestHeaders.set('x-org-id', orgId)
}
} catch {
// молча продолжаем без заголовков
}

return NextResponse.next({ request: { headers: requestHeaders } })
}

// Исключаем статику из middleware
export const config = {
matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}

2. Универсальный Supabase-клиент для Edge-роутов

apps/web/lib/supabase.ts

import { createClient } from '@supabase/supabase-js'
import { createServerClient } from '@supabase/ssr'
import type { NextRequest } from 'next/server'
import { envPublic } from '@potlucky/config'

/\*\*

- Возвращает Supabase-клиент для Edge-хендлеров:
- 1.  Если в запросе есть Authorization: Bearer <token> → используем его (идеально для тестов/e2e).
- 2.  Иначе пытаемся прочитать SSR-cookies (если хендлер принимает NextRequest).
- 3.  Фолбэк — анонимный клиент (дальше RLS отфильтрует доступ).
      \*/
      export function createSupabaseForRequest(
      req: Request | NextRequest,
      resHeaders?: Headers,
      ) {
      const authHeader = req.headers.get('authorization')
      if (authHeader) {
      return createClient(
      envPublic.NEXT_PUBLIC_SUPABASE_URL,
      envPublic.NEXT_PUBLIC_SUPABASE_ANON_KEY,
      {
      global: { headers: { Authorization: authHeader } },
      auth: { persistSession: false },
      }
      )
      }

// SSR-cookies путь (работает, если хендлер принимает NextRequest + у нас есть доступ к cookies через него)
// В Edge route handlers чаще используем токен или анонимный клиент; cookies используются, если NextRequest доступен.
try {
// @ts-expect-error — в рантайме NextRequest
if (typeof (req as NextRequest).cookies?.get === 'function') {
const r = createServerClient(
envPublic.NEXT_PUBLIC_SUPABASE_URL,
envPublic.NEXT_PUBLIC_SUPABASE_ANON_KEY,
{
cookies: {
get: (name: string) => (req as NextRequest).cookies.get(name)?.value,
set: (name, value, options) => {
// опционально: прокидывать куки обратно в ответ
resHeaders?.append('set-cookie', `${name}=${value}; Path=/; HttpOnly; SameSite=Lax`)
},
remove: (name, options) => {
resHeaders?.append('set-cookie', `${name}=; Path=/; Max-Age=0`)
},
},
}
)
return r
}
} catch {
// игнор
}

// Фолбэк: anon
return createClient(
envPublic.NEXT_PUBLIC_SUPABASE_URL,
envPublic.NEXT_PUBLIC_SUPABASE_ANON_KEY,
{ auth: { persistSession: false } }
)
}

3. Auth helper: получить пользователя или отдать 401

apps/web/lib/auth.ts

import { createSupabaseForRequest } from '@/lib/supabase'

export async function getUserOrThrow(req: Request) {
const supabase = createSupabaseForRequest(req)
const { data, error } = await supabase.auth.getUser()
if (error || !data.user) {
const body = JSON.stringify({ error: 'unauthorized' })
return { user: null, fail: new Response(body, { status: 401, headers: { 'content-type': 'application/json' } }) }
}
return { user: data.user, fail: null, supabase }
}

4. Защищённый роут /api/me (Edge)

apps/web/app/api/me/route.ts

export const runtime = 'edge'

import { getUserOrThrow } from '@/lib/auth'
import { createSupabaseForRequest } from '@/lib/supabase'

export async function GET(req: Request) {
const { user, fail } = await getUserOrThrow(req)
if (!user) return fail!

// RLS вернёт только собственные строки
const supabase = createSupabaseForRequest(req)
const [{ data: profile, error: pErr }, { data: memberships, error: mErr }] = await Promise.all([
supabase.from('profiles').select('id, auth_user_id, full_name').maybeSingle(),
supabase.from('memberships').select('org_id, role'),
])

if (pErr || mErr) {
return new Response(JSON.stringify({ error: pErr?.message || mErr?.message }), { status: 500 })
}

return new Response(
JSON.stringify({
user: { id: user.id, email: user.email },
profile,
memberships: memberships ?? [],
}),
{ headers: { 'content-type': 'application/json' } }
)
}

5. Тесты (минимально-надёжные e2e)

apps/web/tests/me.test.ts

import { describe, it, expect } from 'vitest'
import { createClient } from '@supabase/supabase-js'
import { envPublic } from '@potlucky/config'
import { GET as getMe } from '../app/api/me/route'

async function signIn(email: string, password: string) {
const c = createClient(envPublic.NEXT_PUBLIC_SUPABASE_URL, envPublic.NEXT_PUBLIC_SUPABASE_ANON_KEY, {
auth: { persistSession: false },
})
const { data, error } = await c.auth.signInWithPassword({ email, password })
if (error) throw error
return data.session!.access_token
}

function makeReq(token?: string) {
const headers: Record<string, string> = { 'content-type': 'application/json' }
if (token) headers['authorization'] = `Bearer ${token}`
return new Request('http://localhost/api/me', { headers })
}

describe('/api/me', () => {
it('returns 401 without auth', async () => {
const res = await getMe(makeReq())
expect(res.status).toBe(401)
})

it('Alice sees her profile and membership', async () => {
const token = await signIn('alice@example.com', 'Passw0rd!')
const res = await getMe(makeReq(token))
expect(res.status).toBe(200)
const json = await res.json()
expect(json.user.email).toBe('alice@example.com')
// у Alice должен быть хотя бы один membership (Acme)
expect(Array.isArray(json.memberships)).toBe(true)
expect(json.memberships.length).toBeGreaterThan(0)
})

it('Bob is authenticated but has no Acme membership', async () => {
const token = await signIn('bob@example.com', 'Passw0rd!')
const res = await getMe(makeReq(token))
expect(res.status).toBe(200)
const json = await res.json()
expect(json.user.email).toBe('bob@example.com')
// допустимо 0 или просто отсутствие Acme — на этом этапе проверяем, что массив существует
expect(Array.isArray(json.memberships)).toBe(true)
})
})

6. README — ручная проверка

Добавь в корневой README раздел:

### Auth check (локально)

# ENV

NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
SUPABASE_DB_URL=...
SUPABASE_SERVICE_ROLE=...

# сиды/rls (если ещё не выполняли)

pnpm drizzle:generate && pnpm drizzle:push
pnpm db:rls && pnpm db:seed

# токен Alice

node -e "import('@supabase/supabase-js').then(async m=>{ const c=new m.createClient(process.env.NEXT_PUBLIC_SUPABASE_URL,process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,{auth:{persistSession:false}}); const {data}=await c.auth.signInWithPassword({email:'alice@example.com',password:'Passw0rd!'}); console.log(data.session.access_token) })"

# запрос к защищённому роуту

curl -H "Authorization: Bearer <TOKEN>" http://localhost:3000/api/me | jq

⸻

Проверка AC (кратко)

# без токена

curl -i http://localhost:3000/api/me # -> 401

# Alice

TOKEN=$(node scripts/get-token-alice.mjs) # или команда из README
curl -sH "Authorization: Bearer $TOKEN" http://localhost:3000/api/me | jq # -> profile + memberships

Рекомендованный коммит

feat(auth): add Edge middleware user/org context, Supabase SSR helper and protected /api/me route
