T0.2 — packages/config: env-валидация + feature flags (+ 404 guard в web)

Role: Codebase Guardian (Edge/Serverless).
Non-negotiables: centralized config, no прямых process.env в коде, флаги читаются только из @potlucky/config.

Goal

Сделать пакет @potlucky/config с: 1. строгой валидацией env (public/server), 2. централизованными feature-флагами (ONLINE_ORDERING_V1, ORDER_QUEUE_V1, AI_ADVISOR_V1), 3. helper isEnabled(), 4. демонстрацией в apps/web: роут /api/feature-check → 404, когда флаг выключен.

Scope

In: пакет packages/config (public+server схемы через zod), тесты, пример edge-роута в apps/web.
Out: Unleash/remote toggles, пер-тенант/пер-user стратегии (позже).

AC (Gherkin)
• Given в корне .env задано ONLINE_ORDERING_V1=false, When вызываю GET /api/feature-check, Then получаю 404.
• Given ONLINE_ORDERING_V1=true, When вызываю GET /api/feature-check, Then получаю 200 и JSON { feature: "ONLINE_ORDERING_V1", enabled: true }.
• Given не заданы NEXT_PUBLIC_SUPABASE_URL или NEXT_PUBLIC_SUPABASE_ANON_KEY, When выполняю pnpm -w build, Then сборка падает с понятной ошибкой о недостающих переменных.
• Given запускаю pnpm --filter @potlucky/config test, Then все тесты зелёные.

DoD
• packages/config экспортирует envPublic, envServer, flags, isEnabled()
• Никаких прямых обращений к process.env вне @potlucky/config
• Edge-роут /api/feature-check использует isEnabled('ONLINE_ORDERING_V1')
• Документация по required env в README

⸻

Steps

0. Зависимости

pnpm -w add zod
pnpm --filter @potlucky/config add zod

1. Структура пакета

packages/config/
├─ package.json
├─ tsconfig.json
├─ src/
│ ├─ schema.ts
│ ├─ flags.ts
│ ├─ public.ts
│ ├─ server.ts
│ └─ index.ts
└─ tests/
└─ env.test.ts

packages/config/package.json

{
"name": "@potlucky/config",
"version": "0.0.0",
"private": false,
"type": "module",
"main": "dist/index.cjs",
"module": "dist/index.mjs",
"types": "dist/index.d.ts",
"exports": {
".": {
"require": "./dist/index.cjs",
"import": "./dist/index.mjs",
"types": "./dist/index.d.ts"
}
},
"scripts": {
"build": "tsup src/index.ts --dts --format cjs,esm --clean",
"dev": "tsup src/index.ts --dts --format cjs,esm --watch",
"lint": "eslint . --ext .ts",
"typecheck": "tsc -p tsconfig.json --noEmit",
"test": "vitest run"
},
"devDependencies": {
"tsup": "^8.0.0",
"typescript": "^5.6.0",
"vitest": "^2.0.0"
},
"dependencies": {
"zod": "^3.23.8"
}
}

packages/config/src/schema.ts

import { z } from 'zod'

/\*_ Утилита: безопасно приводим строку env в boolean _/
export const toBool = (v: unknown, def = false) => {
if (typeof v === 'boolean') return v
if (typeof v !== 'string') return def
const s = v.trim().toLowerCase()
return s === 'true' || s === '1' || s === 'yes' || s === 'on'
}

/\*_ PUBLIC env — доступно на клиенте (NEXT*PUBLIC*_) \*/
export const PublicEnvSchema = z.object({
NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(10),

// фичефлаги как строки → приводим к boolean с дефолтом false
ONLINE_ORDERING_V1: z.string().optional().transform(v => toBool(v, false)),
ORDER_QUEUE_V1: z.string().optional().transform(v => toBool(v, false)),
AI_ADVISOR_V1: z.string().optional().transform(v => toBool(v, false)),
})

/\*_ SERVER env — только на сервере/edge (не экспонируем в браузер) _/
export const ServerEnvSchema = z.object({
SUPABASE_SERVICE_ROLE: z.string().optional(),
SENTRY_DSN: z.string().optional(),
})

packages/config/src/flags.ts

export type FeatureFlag =
| 'ONLINE_ORDERING_V1'
| 'ORDER_QUEUE_V1'
| 'AI_ADVISOR_V1'

export type FeatureFlags = Record<FeatureFlag, boolean>

packages/config/src/public.ts

import { PublicEnvSchema } from './schema'
import type { FeatureFlags } from './flags'

/\*\*

- Next.js встраивает process.env.\* на этапе сборки.
- В edge/runtime это тоже работает, но ПРИ УСЛОВИИ, что переменные помечены корректно.
- Здесь валидируем public env единожды при инициализации модуля.
  \*/
  const parsed = PublicEnvSchema.safeParse({
  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  ONLINE_ORDERING_V1: process.env.ONLINE_ORDERING_V1,
  ORDER_QUEUE_V1: process.env.ORDER_QUEUE_V1,
  AI_ADVISOR_V1: process.env.AI_ADVISOR_V1,
  })

if (!parsed.success) {
const issues = parsed.error.issues.map(i => `${i.path.join('.')}: ${i.message}`).join('; ')
throw new Error(
`[config] Public env validation failed: ${issues}. ` +
`Ensure NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are set.`,
)
}

export const envPublic = parsed.data

export const flags: FeatureFlags = {
ONLINE_ORDERING_V1: !!envPublic.ONLINE_ORDERING_V1,
ORDER_QUEUE_V1: !!envPublic.ORDER_QUEUE_V1,
AI_ADVISOR_V1: !!envPublic.AI_ADVISOR_V1,
}

/\*_ Простой флаг-чекер. Позже добавим стратегии per-tenant/user. _/
export const isEnabled = (flag: keyof typeof flags) => !!flags[flag]

packages/config/src/server.ts

import { ServerEnvSchema } from './schema'

const parsed = ServerEnvSchema.safeParse({
SUPABASE_SERVICE_ROLE: process.env.SUPABASE_SERVICE_ROLE,
SENTRY_DSN: process.env.SENTRY_DSN,
})

// server vars опциональны на T0.2 — валидируем, но не падаем
export const envServer = parsed.success ? parsed.data : {}

packages/config/src/index.ts

export { envPublic, flags, isEnabled } from './public'
export { envServer } from './server'
export type { FeatureFlag, FeatureFlags } from './flags'

2. Тесты для config

packages/config/tests/env.test.ts

import { describe, it, expect } from 'vitest'

// Важно: тестируем через свежий импорт (эмулируем разные env)
const freshImport = async (vars: Record<string, string | undefined>) => {
for (const [k] of Object.entries(process.env)) {
if (k.startsWith('NEXT*PUBLIC*') || ['ONLINE_ORDERING_V1','ORDER_QUEUE_V1','AI_ADVISOR_V1'].includes(k)) {
delete process.env[k]
}
}
Object.assign(process.env, vars)
// очистка кеша модуля
const modPath = require.resolve('../src/public.ts')
delete require.cache[modPath]
return await import('../src/public')
}

describe('config/public env', () => {
it('fails without required NEXT*PUBLIC*\*', async () => {
await expect(
freshImport({
NEXT_PUBLIC_SUPABASE_URL: undefined,
NEXT_PUBLIC_SUPABASE_ANON_KEY: undefined,
})
).rejects.toThrow(/Public env validation failed/)
})

it('parses flags booleans', async () => {
const mod = await freshImport({
NEXT_PUBLIC_SUPABASE_URL: 'https://example.supabase.co',
NEXT_PUBLIC_SUPABASE_ANON_KEY: 'anon_key_1234567890',
ONLINE_ORDERING_V1: 'true',
ORDER_QUEUE_V1: '0',
AI_ADVISOR_V1: 'yes'
})
expect(mod.flags.ONLINE_ORDERING_V1).toBe(true)
expect(mod.flags.ORDER_QUEUE_V1).toBe(false)
expect(mod.flags.AI_ADVISOR_V1).toBe(true)
expect(mod.isEnabled('ONLINE_ORDERING_V1')).toBe(true)
})
})

3. Демо-роут с 404 guard в apps/web

apps/web/app/api/feature-check/route.ts

export const runtime = 'edge'
import { isEnabled } from '@potlucky/config'

export async function GET() {
if (!isEnabled('ONLINE_ORDERING_V1')) {
return new Response('Not Found', { status: 404 })
}
return new Response(
JSON.stringify({ feature: 'ONLINE_ORDERING_V1', enabled: true }),
{ status: 200, headers: { 'content-type': 'application/json' } }
)
}

Тест для роутa: apps/web/tests/feature-check.test.ts

import { describe, it, expect, beforeAll } from 'vitest'

// Импортируем через require, чтобы подменить env до evaluate модуля
const loadRoute = async () => {
// Настроим required public env
process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://example.supabase.co'
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'anon_key_1234567890'
// Сброс кеша config
const cfgPath = require.resolve('@potlucky/config/dist/index.cjs')
delete require.cache[cfgPath]
return await import('../app/api/feature-check/route')
}

describe('feature-check route', () => {
it('returns 404 when flag is off', async () => {
process.env.ONLINE_ORDERING_V1 = 'false'
const { GET } = await loadRoute()
const res = await GET()
expect(res.status).toBe(404)
})

it('returns 200 json when flag is on', async () => {
process.env.ONLINE_ORDERING_V1 = 'true'
const { GET } = await loadRoute()
const res = await GET()
expect(res.status).toBe(200)
const json = await res.json()
expect(json).toEqual({ feature: 'ONLINE_ORDERING_V1', enabled: true })
})
})

4. Обнови apps/web/tsconfig.json (пути уже в tsconfig.base.json; ничего добавлять не нужно)

5. Обнови root README (env)

Добавь раздел Environment:

# Required public env (build will fail if missing)

NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=

# Feature flags (optional, default=false)

ONLINE_ORDERING_V1=false
ORDER_QUEUE_V1=false
AI_ADVISOR_V1=false

⸻

Проверка AC

# в корне:

export NEXT_PUBLIC_SUPABASE_URL="https://example.supabase.co"
export NEXT_PUBLIC_SUPABASE_ANON_KEY="anon_key_1234567890"

# 1) флаг off

export ONLINE_ORDERING_V1="false"
pnpm --filter @potlucky/web dev

# GET http://localhost:3000/api/feature-check → 404

# 2) флаг on

export ONLINE_ORDERING_V1="true"

# перезапусти dev или используй .env.local

# GET /api/feature-check → 200 {"feature":"ONLINE_ORDERING_V1","enabled":true}

# 3) build fails without required env

unset NEXT_PUBLIC_SUPABASE_URL
pnpm -w build # должно упасть с ошибкой из @potlucky/config

Рекомендованный коммит

feat(config): add centralized env validation and feature flags; demo edge 404 guard
